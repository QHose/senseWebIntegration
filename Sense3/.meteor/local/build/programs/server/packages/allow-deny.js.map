{"version":3,"sources":["meteor://ðŸ’»app/packages/allow-deny/allow-deny.js"],"names":[],"mappings":"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","file":"/packages/allow-deny.js","sourcesContent":["///\n/// Remote methods and access control.\n///\n\n// Restrict default mutators on collection. allow() and deny() take the\n// same options:\n//\n// options.insert {Function(userId, doc)}\n//   return true to allow/deny adding this document\n//\n// options.update {Function(userId, docs, fields, modifier)}\n//   return true to allow/deny updating these documents.\n//   `fields` is passed as an array of fields that are to be modified\n//\n// options.remove {Function(userId, docs)}\n//   return true to allow/deny removing these documents\n//\n// options.fetch {Array}\n//   Fields to fetch for these validators. If any call to allow or deny\n//   does not have this option then all fields are loaded.\n//\n// allow and deny can be called multiple times. The validators are\n// evaluated as follows:\n// - If neither deny() nor allow() has been called on the collection,\n//   then the request is allowed if and only if the \"insecure\" smart\n//   package is in use.\n// - Otherwise, if any deny() function returns true, the request is denied.\n// - Otherwise, if any allow() function returns true, the request is allowed.\n// - Otherwise, the request is denied.\n//\n// Meteor may call your deny() and allow() functions in any order, and may not\n// call all of them if it is able to make a decision without calling them all\n// (so don't include side effects).\n\nAllowDeny = {\n  CollectionPrototype: {}\n};\n\n// In the `mongo` package, we will extend Mongo.Collection.prototype with these\n// methods\nconst CollectionPrototype = AllowDeny.CollectionPrototype;\n\n/**\n * @summary Allow users to write directly to this collection from client code, subject to limitations you define.\n * @locus Server\n * @method allow\n * @memberOf Mongo.Collection\n * @instance\n * @param {Object} options\n * @param {Function} options.insert,update,remove Functions that look at a proposed modification to the database and return true if it should be allowed.\n * @param {String[]} options.fetch Optional performance enhancement. Limits the fields that will be fetched from the database for inspection by your `update` and `remove` functions.\n * @param {Function} options.transform Overrides `transform` on the  [`Collection`](#collections).  Pass `null` to disable transformation.\n */\nCollectionPrototype.allow = function(options) {\n  addValidator(this, 'allow', options);\n};\n\n/**\n * @summary Override `allow` rules.\n * @locus Server\n * @method deny\n * @memberOf Mongo.Collection\n * @instance\n * @param {Object} options\n * @param {Function} options.insert,update,remove Functions that look at a proposed modification to the database and return true if it should be denied, even if an [allow](#allow) rule says otherwise.\n * @param {String[]} options.fetch Optional performance enhancement. Limits the fields that will be fetched from the database for inspection by your `update` and `remove` functions.\n * @param {Function} options.transform Overrides `transform` on the  [`Collection`](#collections).  Pass `null` to disable transformation.\n */\nCollectionPrototype.deny = function(options) {\n  addValidator(this, 'deny', options);\n};\n\nCollectionPrototype._defineMutationMethods = function() {\n  const self = this;\n\n  // set to true once we call any allow or deny methods. If true, use\n  // allow/deny semantics. If false, use insecure mode semantics.\n  self._restricted = false;\n\n  // Insecure mode (default to allowing writes). Defaults to 'undefined' which\n  // means insecure iff the insecure package is loaded. This property can be\n  // overriden by tests or packages wishing to change insecure mode behavior of\n  // their collections.\n  self._insecure = undefined;\n\n  self._validators = {\n    insert: {allow: [], deny: []},\n    update: {allow: [], deny: []},\n    remove: {allow: [], deny: []},\n    upsert: {allow: [], deny: []}, // dummy arrays; can't set these!\n    fetch: [],\n    fetchAllFields: false\n  };\n\n  if (!self._name)\n    return; // anonymous collection\n\n  // XXX Think about method namespacing. Maybe methods should be\n  // \"Meteor:Mongo:insert/NAME\"?\n  self._prefix = '/' + self._name + '/';\n\n  // mutation methods\n  if (self._connection) {\n    const m = {};\n\n    _.each(['insert', 'update', 'remove'], function (method) {\n      m[self._prefix + method] = function (/* ... */) {\n        // All the methods do their own validation, instead of using check().\n        check(arguments, [Match.Any]);\n        const args = _.toArray(arguments);\n        try {\n          // For an insert, if the client didn't specify an _id, generate one\n          // now; because this uses DDP.randomStream, it will be consistent with\n          // what the client generated. We generate it now rather than later so\n          // that if (eg) an allow/deny rule does an insert to the same\n          // collection (not that it really should), the generated _id will\n          // still be the first use of the stream and will be consistent.\n          //\n          // However, we don't actually stick the _id onto the document yet,\n          // because we want allow/deny rules to be able to differentiate\n          // between arbitrary client-specified _id fields and merely\n          // client-controlled-via-randomSeed fields.\n          let generatedId = null;\n          if (method === \"insert\" && !_.has(args[0], '_id')) {\n            generatedId = self._makeNewID();\n          }\n\n          if (this.isSimulation) {\n            // In a client simulation, you can do any mutation (even with a\n            // complex selector).\n            if (generatedId !== null)\n              args[0]._id = generatedId;\n            return self._collection[method].apply(\n              self._collection, args);\n          }\n\n          // This is the server receiving a method call from the client.\n\n          // We don't allow arbitrary selectors in mutations from the client: only\n          // single-ID selectors.\n          if (method !== 'insert')\n            throwIfSelectorIsNotId(args[0], method);\n\n          if (self._restricted) {\n            // short circuit if there is no way it will pass.\n            if (self._validators[method].allow.length === 0) {\n              throw new Meteor.Error(\n                403, \"Access denied. No allow validators set on restricted \" +\n                  \"collection for method '\" + method + \"'.\");\n            }\n\n            const validatedMethodName =\n                  '_validated' + method.charAt(0).toUpperCase() + method.slice(1);\n            args.unshift(this.userId);\n            method === 'insert' && args.push(generatedId);\n            return self[validatedMethodName].apply(self, args);\n          } else if (self._isInsecure()) {\n            if (generatedId !== null)\n              args[0]._id = generatedId;\n            // In insecure mode, allow any mutation (with a simple selector).\n            // XXX This is kind of bogus.  Instead of blindly passing whatever\n            //     we get from the network to this function, we should actually\n            //     know the correct arguments for the function and pass just\n            //     them.  For example, if you have an extraneous extra null\n            //     argument and this is Mongo on the server, the .wrapAsync'd\n            //     functions like update will get confused and pass the\n            //     \"fut.resolver()\" in the wrong slot, where _update will never\n            //     invoke it. Bam, broken DDP connection.  Probably should just\n            //     take this whole method and write it three times, invoking\n            //     helpers for the common code.\n            return self._collection[method].apply(self._collection, args);\n          } else {\n            // In secure mode, if we haven't called allow or deny, then nothing\n            // is permitted.\n            throw new Meteor.Error(403, \"Access denied\");\n          }\n        } catch (e) {\n          if (e.name === 'MongoError' || e.name === 'MinimongoError') {\n            throw new Meteor.Error(409, e.toString());\n          } else {\n            throw e;\n          }\n        }\n      };\n    });\n    // Minimongo on the server gets no stubs; instead, by default\n    // it wait()s until its result is ready, yielding.\n    // This matches the behavior of macromongo on the server better.\n    // XXX see #MeteorServerNull\n    if (Meteor.isClient || self._connection === Meteor.server)\n      self._connection.methods(m);\n  }\n};\n\nCollectionPrototype._updateFetch = function (fields) {\n  const self = this;\n\n  if (!self._validators.fetchAllFields) {\n    if (fields) {\n      self._validators.fetch = _.union(self._validators.fetch, fields);\n    } else {\n      self._validators.fetchAllFields = true;\n      // clear fetch just to make sure we don't accidentally read it\n      self._validators.fetch = null;\n    }\n  }\n};\n\nCollectionPrototype._isInsecure = function () {\n  const self = this;\n  if (self._insecure === undefined)\n    return !!Package.insecure;\n  return self._insecure;\n};\n\nCollectionPrototype._validatedInsert = function (userId, doc,\n                                                         generatedId) {\n  const self = this;\n\n  // call user validators.\n  // Any deny returns true means denied.\n  if (_.any(self._validators.insert.deny, function(validator) {\n    return validator(userId, docToValidate(validator, doc, generatedId));\n  })) {\n    throw new Meteor.Error(403, \"Access denied\");\n  }\n  // Any allow returns true means proceed. Throw error if they all fail.\n  if (_.all(self._validators.insert.allow, function(validator) {\n    return !validator(userId, docToValidate(validator, doc, generatedId));\n  })) {\n    throw new Meteor.Error(403, \"Access denied\");\n  }\n\n  // If we generated an ID above, insert it now: after the validation, but\n  // before actually inserting.\n  if (generatedId !== null)\n    doc._id = generatedId;\n\n  self._collection.insert.call(self._collection, doc);\n};\n\n// Simulate a mongo `update` operation while validating that the access\n// control rules set by calls to `allow/deny` are satisfied. If all\n// pass, rewrite the mongo operation to use $in to set the list of\n// document ids to change ##ValidatedChange\nCollectionPrototype._validatedUpdate = function(\n    userId, selector, mutator, options) {\n  const self = this;\n\n  check(mutator, Object);\n\n  options = _.clone(options) || {};\n\n  if (!LocalCollection._selectorIsIdPerhapsAsObject(selector))\n    throw new Error(\"validated update should be of a single ID\");\n\n  // We don't support upserts because they don't fit nicely into allow/deny\n  // rules.\n  if (options.upsert)\n    throw new Meteor.Error(403, \"Access denied. Upserts not \" +\n                           \"allowed in a restricted collection.\");\n\n  const noReplaceError = \"Access denied. In a restricted collection you can only\" +\n        \" update documents, not replace them. Use a Mongo update operator, such \" +\n        \"as '$set'.\";\n\n  // compute modified fields\n  const fields = [];\n  if (_.isEmpty(mutator)) {\n    throw new Meteor.Error(403, noReplaceError);\n  }\n  _.each(mutator, function (params, op) {\n    if (op.charAt(0) !== '$') {\n      throw new Meteor.Error(403, noReplaceError);\n    } else if (!_.has(ALLOWED_UPDATE_OPERATIONS, op)) {\n      throw new Meteor.Error(\n        403, \"Access denied. Operator \" + op + \" not allowed in a restricted collection.\");\n    } else {\n      _.each(_.keys(params), function (field) {\n        // treat dotted fields as if they are replacing their\n        // top-level part\n        if (field.indexOf('.') !== -1)\n          field = field.substring(0, field.indexOf('.'));\n\n        // record the field we are trying to change\n        if (!_.contains(fields, field))\n          fields.push(field);\n      });\n    }\n  });\n\n  const findOptions = {transform: null};\n  if (!self._validators.fetchAllFields) {\n    findOptions.fields = {};\n    _.each(self._validators.fetch, function(fieldName) {\n      findOptions.fields[fieldName] = 1;\n    });\n  }\n\n  const doc = self._collection.findOne(selector, findOptions);\n  if (!doc)  // none satisfied!\n    return 0;\n\n  // call user validators.\n  // Any deny returns true means denied.\n  if (_.any(self._validators.update.deny, function(validator) {\n    const factoriedDoc = transformDoc(validator, doc);\n    return validator(userId,\n                     factoriedDoc,\n                     fields,\n                     mutator);\n  })) {\n    throw new Meteor.Error(403, \"Access denied\");\n  }\n  // Any allow returns true means proceed. Throw error if they all fail.\n  if (_.all(self._validators.update.allow, function(validator) {\n    const factoriedDoc = transformDoc(validator, doc);\n    return !validator(userId,\n                      factoriedDoc,\n                      fields,\n                      mutator);\n  })) {\n    throw new Meteor.Error(403, \"Access denied\");\n  }\n\n  options._forbidReplace = true;\n\n  // Back when we supported arbitrary client-provided selectors, we actually\n  // rewrote the selector to include an _id clause before passing to Mongo to\n  // avoid races, but since selector is guaranteed to already just be an ID, we\n  // don't have to any more.\n\n  return self._collection.update.call(\n    self._collection, selector, mutator, options);\n};\n\n// Only allow these operations in validated updates. Specifically\n// whitelist operations, rather than blacklist, so new complex\n// operations that are added aren't automatically allowed. A complex\n// operation is one that does more than just modify its target\n// field. For now this contains all update operations except '$rename'.\n// http://docs.mongodb.org/manual/reference/operators/#update\nconst ALLOWED_UPDATE_OPERATIONS = {\n  $inc:1, $set:1, $unset:1, $addToSet:1, $pop:1, $pullAll:1, $pull:1,\n  $pushAll:1, $push:1, $bit:1\n};\n\n// Simulate a mongo `remove` operation while validating access control\n// rules. See #ValidatedChange\nCollectionPrototype._validatedRemove = function(userId, selector) {\n  const self = this;\n\n  const findOptions = {transform: null};\n  if (!self._validators.fetchAllFields) {\n    findOptions.fields = {};\n    _.each(self._validators.fetch, function(fieldName) {\n      findOptions.fields[fieldName] = 1;\n    });\n  }\n\n  const doc = self._collection.findOne(selector, findOptions);\n  if (!doc)\n    return 0;\n\n  // call user validators.\n  // Any deny returns true means denied.\n  if (_.any(self._validators.remove.deny, function(validator) {\n    return validator(userId, transformDoc(validator, doc));\n  })) {\n    throw new Meteor.Error(403, \"Access denied\");\n  }\n  // Any allow returns true means proceed. Throw error if they all fail.\n  if (_.all(self._validators.remove.allow, function(validator) {\n    return !validator(userId, transformDoc(validator, doc));\n  })) {\n    throw new Meteor.Error(403, \"Access denied\");\n  }\n\n  // Back when we supported arbitrary client-provided selectors, we actually\n  // rewrote the selector to {_id: {$in: [ids that we found]}} before passing to\n  // Mongo to avoid races, but since selector is guaranteed to already just be\n  // an ID, we don't have to any more.\n\n  return self._collection.remove.call(self._collection, selector);\n};\n\nCollectionPrototype._callMutatorMethod = function _callMutatorMethod(name, args, callback) {\n  if (Meteor.isClient && !callback && !alreadyInSimulation()) {\n    // Client can't block, so it can't report errors by exception,\n    // only by callback. If they forget the callback, give them a\n    // default one that logs the error, so they aren't totally\n    // baffled if their writes don't work because their database is\n    // down.\n    // Don't give a default callback in simulation, because inside stubs we\n    // want to return the results from the local collection immediately and\n    // not force a callback.\n    callback = function (err) {\n      if (err)\n        Meteor._debug(name + \" failed: \" + (err.reason || err.stack));\n    };\n  }\n\n  // For two out of three mutator methods, the first argument is a selector\n  const firstArgIsSelector = name === \"update\" || name === \"remove\";\n  if (firstArgIsSelector && !alreadyInSimulation()) {\n    // If we're about to actually send an RPC, we should throw an error if\n    // this is a non-ID selector, because the mutation methods only allow\n    // single-ID selectors. (If we don't throw here, we'll see flicker.)\n    throwIfSelectorIsNotId(args[0], name);\n  }\n\n  const mutatorMethodName = this._prefix + name;\n  return this._connection.apply(\n    mutatorMethodName, args, { returnStubValue: true }, callback);\n}\n\nfunction transformDoc(validator, doc) {\n  if (validator.transform)\n    return validator.transform(doc);\n  return doc;\n}\n\nfunction docToValidate(validator, doc, generatedId) {\n  let ret = doc;\n  if (validator.transform) {\n    ret = EJSON.clone(doc);\n    // If you set a server-side transform on your collection, then you don't get\n    // to tell the difference between \"client specified the ID\" and \"server\n    // generated the ID\", because transforms expect to get _id.  If you want to\n    // do that check, you can do it with a specific\n    // `C.allow({insert: f, transform: null})` validator.\n    if (generatedId !== null) {\n      ret._id = generatedId;\n    }\n    ret = validator.transform(ret);\n  }\n  return ret;\n}\n\nfunction addValidator(collection, allowOrDeny, options) {\n  // validate keys\n  const VALID_KEYS = ['insert', 'update', 'remove', 'fetch', 'transform'];\n  _.each(_.keys(options), function (key) {\n    if (!_.contains(VALID_KEYS, key))\n      throw new Error(allowOrDeny + \": Invalid key: \" + key);\n  });\n\n  collection._restricted = true;\n\n  _.each(['insert', 'update', 'remove'], function (name) {\n    if (options.hasOwnProperty(name)) {\n      if (!(options[name] instanceof Function)) {\n        throw new Error(allowOrDeny + \": Value for `\" + name + \"` must be a function\");\n      }\n\n      // If the transform is specified at all (including as 'null') in this\n      // call, then take that; otherwise, take the transform from the\n      // collection.\n      if (options.transform === undefined) {\n        options[name].transform = collection._transform;  // already wrapped\n      } else {\n        options[name].transform = LocalCollection.wrapTransform(\n          options.transform);\n      }\n\n      collection._validators[name][allowOrDeny].push(options[name]);\n    }\n  });\n\n  // Only update the fetch fields if we're passed things that affect\n  // fetching. This way allow({}) and allow({insert: f}) don't result in\n  // setting fetchAllFields\n  if (options.update || options.remove || options.fetch) {\n    if (options.fetch && !(options.fetch instanceof Array)) {\n      throw new Error(allowOrDeny + \": Value for `fetch` must be an array\");\n    }\n    collection._updateFetch(options.fetch);\n  }\n}\n\nfunction throwIfSelectorIsNotId(selector, methodName) {\n  if (!LocalCollection._selectorIsIdPerhapsAsObject(selector)) {\n    throw new Meteor.Error(\n      403, \"Not permitted. Untrusted code may only \" + methodName +\n        \" documents by ID.\");\n  }\n};\n\n// Determine if we are in a DDP method simulation\nfunction alreadyInSimulation() {\n  const enclosing = DDP._CurrentInvocation.get();\n  return enclosing && enclosing.isSimulation;\n}\n"]}